fn mat_vec(m: &[u64; 9], v: &[u64; 3], p: u64) -> u64 {
    (((m[0] + m[3] + m[6]) % p) * v[0]) % p
        + (((m[1] + m[4] + m[7]) % p) * v[1]) % p
        + (((m[2] + m[5] + m[8]) % p) * v[2]) % p
}

fn mat_mul3(x: &[u64; 9], y: &[u64; 9], p: u64) -> [u64; 9] {
    [
        (x[0] * y[0] + x[1] * y[3] + x[2] * y[6]) % p,
        (x[0] * y[1] + x[1] * y[4] + x[2] * y[7]) % p,
        (x[0] * y[2] + x[1] * y[5] + x[2] * y[8]) % p,
        (x[3] * y[0] + x[4] * y[3] + x[5] * y[6]) % p,
        (x[3] * y[1] + x[4] * y[4] + x[5] * y[7]) % p,
        (x[3] * y[2] + x[4] * y[5] + x[5] * y[8]) % p,
        (x[6] * y[0] + x[7] * y[3] + x[8] * y[6]) % p,
        (x[6] * y[1] + x[7] * y[4] + x[8] * y[7]) % p,
        (x[6] * y[2] + x[7] * y[5] + x[8] * y[8]) % p,
    ]
}

fn pow_mat3(m: &[u64; 9], n: u64, p: u64) -> [u64; 9] {
    let mut m = m.clone();
    let mut res = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    for i in 0.. {
        if n >> i == 0 {
            break;
        }
        if n >> i & 1 == 1 {
            res = mat_mul2(&res, &m, p);
        }
        m = mat_mul2(&m, &m, p);
    }
    res
}
